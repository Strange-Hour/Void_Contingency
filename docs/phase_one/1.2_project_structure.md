# 1.2 Project Structure Setup

This guide will help you set up the initial project structure for Void Contingency. We'll create a well-organized directory structure and set up the basic files needed to start development.

## Overview

We'll create a modular project structure that follows modern C++ best practices and makes it easy to add new features as the project grows.

## Step 1: Create Directory Structure

### 1.1 Create Base Directories

Create the following directory structure in your project root:

```bash
VoidContingency/
├── src/                    # Source files
│   ├── core/              # Core game systems
│   ├── game/              # Game-specific code
│   ├── graphics/          # Graphics and rendering
│   ├── input/             # Input handling
│   ├── network/           # Networking code
│   ├── physics/           # Physics system
│   ├── ui/                # User interface
│   └── utils/             # Utility functions
├── include/               # Header files
│   ├── core/             # Core system headers
│   ├── game/             # Game-specific headers
│   ├── graphics/         # Graphics headers
│   ├── input/            # Input system headers
│   ├── network/          # Networking headers
│   ├── physics/          # Physics system headers
│   ├── ui/               # UI system headers
│   └── utils/            # Utility headers
├── tests/                # Test files
│   ├── unit/            # Unit tests
│   └── integration/     # Integration tests
├── assets/              # Game assets
│   ├── graphics/        # Images, sprites
│   ├── audio/          # Sound effects, music
│   └── data/           # Game data files
├── docs/               # Documentation
├── scripts/            # Build and utility scripts
└── third_party/        # Third-party libraries
```

### 1.2 Create Initial Files

Create these essential files:

1. `CMakeLists.txt` in the root directory:

```cmake
cmake_minimum_required(VERSION 3.15)
project(VoidContingency VERSION 1.0.0 LANGUAGES CXX)

# Set C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Build type
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
endif()

# Output directories
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# Add subdirectories
add_subdirectory(src)
add_subdirectory(tests)

# Enable testing
enable_testing()
include(CTest)
```

2. `src/CMakeLists.txt`:

```cmake
# Add source files
file(GLOB_RECURSE SOURCES
    "*.cpp"
    "core/*.cpp"
    "game/*.cpp"
    "graphics/*.cpp"
    "input/*.cpp"
    "network/*.cpp"
    "physics/*.cpp"
    "ui/*.cpp"
    "utils/*.cpp"
)

# Create main executable
add_executable(${PROJECT_NAME} ${SOURCES})

# Include directories
target_include_directories(${PROJECT_NAME}
    PRIVATE
        ${CMAKE_SOURCE_DIR}/include
        ${CMAKE_CURRENT_SOURCE_DIR}
)

# Link libraries
target_link_libraries(${PROJECT_NAME}
    PRIVATE
        # Add external libraries here
)
```

3. `tests/CMakeLists.txt`:

```cmake
# Find GTest package
find_package(GTest REQUIRED)

# Add test executable
add_executable(unit_tests
    unit/main.cpp
    # Add test files here
)

# Link test libraries
target_link_libraries(unit_tests
    PRIVATE
        GTest::GTest
        GTest::Main
        ${PROJECT_NAME}
)

# Add tests to CTest
add_test(NAME unit_tests COMMAND unit_tests)
```

## Step 2: Create Core Classes

### 2.1 Create Base Classes

Create these initial header files:

1. `include/core/Game.hpp`:

```cpp
#pragma once

namespace void_contingency {
namespace core {

class Game {
public:
    Game();
    ~Game();

    void initialize();
    void run();
    void shutdown();

private:
    bool is_running_;
    void process_input();
    void update();
    void render();
};

} // namespace core
} // namespace void_contingency
```

2. `include/core/Engine.hpp`:

```cpp
#pragma once

namespace void_contingency {
namespace core {

class Engine {
public:
    static Engine& get_instance();

    void initialize();
    void shutdown();

    // Prevent copying
    Engine(const Engine&) = delete;
    Engine& operator=(const Engine&) = delete;

private:
    Engine() = default;
    ~Engine() = default;
};

} // namespace core
} // namespace void_contingency
```

### 2.2 Implement Core Classes

1. `src/core/Game.cpp`:

```cpp
#include "core/Game.hpp"
#include <iostream>

namespace void_contingency {
namespace core {

Game::Game() : is_running_(false) {}

Game::~Game() {
    shutdown();
}

void Game::initialize() {
    std::cout << "Initializing game..." << std::endl;
    is_running_ = true;
}

void Game::run() {
    while (is_running_) {
        process_input();
        update();
        render();
    }
}

void Game::shutdown() {
    std::cout << "Shutting down game..." << std::endl;
    is_running_ = false;
}

void Game::process_input() {
    // TODO: Implement input processing
}

void Game::update() {
    // TODO: Implement game update
}

void Game::render() {
    // TODO: Implement rendering
}

} // namespace core
} // namespace void_contingency
```

2. `src/core/Engine.cpp`:

```cpp
#include "core/Engine.hpp"
#include <iostream>

namespace void_contingency {
namespace core {

Engine& Engine::get_instance() {
    static Engine instance;
    return instance;
}

void Engine::initialize() {
    std::cout << "Initializing engine..." << std::endl;
}

void Engine::shutdown() {
    std::cout << "Shutting down engine..." << std::endl;
}

} // namespace core
} // namespace void_contingency
```

## Step 3: Create Main Entry Point

Create `src/main.cpp`:

```cpp
#include "core/Game.hpp"
#include "core/Engine.hpp"

int main(int argc, char* argv[]) {
    try {
        // Initialize engine
        void_contingency::core::Engine::get_instance().initialize();

        // Create and run game
        void_contingency::core::Game game;
        game.initialize();
        game.run();

        // Shutdown engine
        void_contingency::core::Engine::get_instance().shutdown();

        return 0;
    }
    catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }
}
```

## Step 4: Set Up Logging System

### 4.1 Create Logger Class

Create `include/utils/Logger.hpp`:

```cpp
#pragma once
#include <string>
#include <fstream>

namespace void_contingency {
namespace utils {

enum class LogLevel {
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    FATAL
};

class Logger {
public:
    static Logger& get_instance();

    void initialize(const std::string& log_file);
    void log(LogLevel level, const std::string& message);
    void shutdown();

private:
    Logger() = default;
    ~Logger() = default;

    std::ofstream log_file_;
    bool is_initialized_ = false;
};

} // namespace utils
} // namespace void_contingency
```

### 4.2 Implement Logger

Create `src/utils/Logger.cpp`:

```cpp
#include "utils/Logger.hpp"
#include <iostream>
#include <ctime>

namespace void_contingency {
namespace utils {

Logger& Logger::get_instance() {
    static Logger instance;
    return instance;
}

void Logger::initialize(const std::string& log_file) {
    if (!is_initialized_) {
        log_file_.open(log_file, std::ios::app);
        is_initialized_ = true;
    }
}

void Logger::log(LogLevel level, const std::string& message) {
    if (!is_initialized_) return;

    std::time_t now = std::time(nullptr);
    std::string time_str = std::ctime(&now);
    time_str.pop_back(); // Remove newline

    std::string level_str;
    switch (level) {
        case LogLevel::DEBUG:   level_str = "DEBUG";   break;
        case LogLevel::INFO:    level_str = "INFO";    break;
        case LogLevel::WARNING: level_str = "WARNING"; break;
        case LogLevel::ERROR:   level_str = "ERROR";   break;
        case LogLevel::FATAL:   level_str = "FATAL";   break;
    }

    log_file_ << "[" << time_str << "] [" << level_str << "] " << message << std::endl;
}

void Logger::shutdown() {
    if (is_initialized_) {
        log_file_.close();
        is_initialized_ = false;
    }
}

} // namespace utils
} // namespace void_contingency
```

## Step 5: Set Up Unit Testing Framework

### 5.1 Create Test Main

Create `tests/unit/main.cpp`:

```cpp
#include <gtest/gtest.h>

int main(int argc, char **argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

### 5.2 Create Sample Test

Create `tests/unit/core/GameTest.cpp`:

```cpp
#include <gtest/gtest.h>
#include "core/Game.hpp"

TEST(GameTest, Initialization) {
    void_contingency::core::Game game;
    // Add test cases here
}
```

## Next Steps

After setting up the project structure, you should:

1. Build the project to verify everything compiles
2. Run the unit tests to ensure the testing framework works
3. Start implementing the core game systems
4. Add more test cases as you develop features

## Troubleshooting

If you encounter issues:

1. Check that all directories are created correctly
2. Verify CMake configuration
3. Ensure all include paths are correct
4. Check that the build system can find all dependencies
5. Verify that the logging system is working
